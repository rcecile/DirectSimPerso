/**
 * @file  make_cat.cc based on rdlss.cc
 * @brief Read over-density grid and simulate galaxy catalog
 *
 * @author rdlss.cc Alex Abate
 * @author make_cat.cc Reza Ansari, Cecile Renault, Jean-Stephane Ricol
 *
 */

#include <iostream>
#include <fstream>
#include <string>
#include <math.h>
#include <typeinfo>

// sophya
#include "machdefs.h"
#include "sopnamsp.h"
#include "timing.h"
#include "array.h"
#include "hisprof.h"
#include "histerr.h"
#include "histinit.h"
#include "fiosinit.h"
#include "fitsioserver.h"
#include "fftwserver.h"
#include "resusage.h"
#include "randfmt.h"

// DirectSim
#include "mydefrg.h"
#include "mass2gal.h"
#include "myschechter.h"
#include "multitypzlf.h"
#include "cosmocalcs.h"
#include "gftdist.h"
#include "constcosmo.h"

void usage(void);
void usage(void) {

  cout << endl<<" Usage: rdlss [...options...]                  "<<endl<<endl;

  cout << "  Simulate a galaxy catalog from an input over-density     "<<endl;
  cout << "  grid. Over-density grid is generated by simdensity and   "<<endl;
  cout << "  supplied to the program with option -C. The simulation id"<<endl;
  cout << "  is supplied with option -i and is included in each       "<<endl;
  cout << "  galaxy's id in the following way: galaxy '1' will have a "<<endl;
  cout << "  full id number of [id]00,000,000,001, galaxy '2' will    "<<endl;
  cout << "  have a full id number of [id]00,000,000,002. This is so  "<<endl;
  cout << "  galaxies can be traced back to their original over-      "<<endl;
  cout << "  density simulations.                                     "<<endl;
  cout << endl;
        
  cout << "  To stop unnecessary simulation of extremely faint        "<<endl;
  cout << "  galaxies apply a cut on the minimum absolute magnitude   "<<endl;
  cout << "  with option -M. Only applies if simulating full galaxy   "<<endl;
  cout << "  catalog.                                                 "<<endl;
  cout << endl;
  cout << "  -L input_LF_param_file: input text file name containing LF parameters \n" <<endl;
  cout << endl;

  cout << "  To simulate catalog within an observation cone, use      "<<endl;
  cout << "  option -a to set the maximum radius in radians a galaxy  "<<endl;
  cout << "  can be from the simulation center.                       "<<endl;
  cout << endl;
        
  cout << "  To simulate a catalog where the z dimension is made to be"<<endl;
  cout << "  the 'radial' direction use option -z.                    "<<endl;
  cout << endl;
        
  cout << "  To not simulate galaxy clustering use option -s to supply"<<endl;
  cout << "  the required galaxy density (number of galaxies per grid "<<endl;
  cout << "  cell).                                                   "<<endl;
  cout << endl;

  cout << "  Option -R ensure that the galaxies are randomly          "<<endl;
  cout << "  positioned within the cells of the over-density grid     "<<endl;
  cout << endl;
        
  // debug
        
  cout << "  The catalog is output to the file specified with option  "<<endl;
  cout << "  -O. There are 4 possible types of outputs:               "<<endl;
  cout << "   type 0: Output full galaxy catalog, either with galaxy  "<<endl; 
  cout << "           clustering or not [DEFAULT]                     "<<endl;
  cout << "   type 1: Output simple catalog: ra,dec,z only [OPTION -S]"<<endl;
  cout << "   type 2: Output catalog of just (true) redshifts         "<<endl;
  cout << "           [OPTION -Z]                                     "<<endl;
  cout << "   type 3: Output a histogram of redshifts [OPTION -H]     "<<endl;
  cout << endl;
        
        
  cout << "    EXAMPLE 1: Simulate a galaxy catalog from an over-     "<<endl;
  cout << "    density distributionin file odens.fits.  We want the   "<<endl;
  cout << "    survey to have a circular sky area with radius = pi/4  "<<endl;
  cout << "    radians, and galaxies with randomized positions in the "<<endl;
  cout << "    pixels. So not to produce too many galaxies so the     "<<endl;
  cout << "    absolute magnitude cut is set. This throws out any     "<<endl;
  cout << "    galaxies with an unobservable absolute magnitude given "<<endl;
  cout << "    their redshifts. This is simulation number 1 so the id "<<endl;
  cout << "    should be 1. The output catalog will be saved to       "<<endl;
  cout << "    out.fits:                                              "<<endl;
  cout << endl;
        
  cout << "    $ rdlss -L input_schech -C odens.fits -O out.fits -a 0.7854 -i 1 -R -M "<<endl;
  cout << endl;
        
  cout << "    EXAMPLE 2: Similar to example 1, but now write only    "<<endl;
  cout << "    the true redshifts to the galaxy catalog and DON'T     "<<endl;
  cout << "    set the absolute magnitude cut:                        "<<endl;
  cout <<endl;
        
  cout << "    $ rdlss -L input_schech -C odens.fits -O ztrue.fits -i 1 -R -Z         "<<endl;
  cout << endl;

  cout << " -O : out_file: filename that the output is written to      "<<endl;
  cout << " -C : over_dens_file: FITS file containing over-density grid"<<endl;
  cout << " -i : id: Simulation identifier, integer >=1 [default=1]    "<<endl;
  cout << " -M : Don't add galaxies with M>AbsMagCut(z) [default=YES]  "<<endl; 
  cout << " -L : luminosity functions input_schech_param_file  "<<endl; 
  cout << " -G : golden sample cut (m_i<25.3) [default=NO]           "<<endl; 
  cout << " -R : Randomise galaxy positions within cell [default=NO]   "<<endl;
  cout << " -a : SkyArea: Radius of survey sky area in radians (assumed"<<endl;
  cout << "       circular) [default=2PI]                              "<<endl;
  cout << " -z : z dimension of the over_dens_file is 'radial' [default=NO] "<<endl;
  cout << " -N : debug_out: Output mass cube, ngals cube to files      "<<endl;
  cout <<"       [debug_out]_ngals.fits and [debug_out]_mass.fits      "<<endl;
  cout << endl;
}

int main(int narg, char* arg[]) {

  cout << " ==== rdlss.cc program , simulating galaxy catalog from"<<endl;
  cout << " input over-density grid  ==== " << endl;
        
  // Make sure SOPHYA modules are initialized 
  SophyaInit();  
  FitsIOServerInit();
  InitTim();
  cout<<endl<<endl;


  string infile;            // name of over-density grid to read in
  string outfile;           // name of file to output to
  string inlfname;           // name of file to output to
  string debug_out;         // write output to here if debugging 
  double maxRadius = 6.3;   // max radius in radians gal can be from sim center
  bool doSkyAreaCut=false;  // throw out gals with theta (co-tangent wrt z axis)>maxRadius
  bool doVeryFaintCut=false;// cut on min absolute magnitude(z) 
  bool doGoldenCut=false;   // Golden sample cut
  //    bool doDebug=false;       // write out ngals, mass cubes
  bool doDebug=false;       // write out ngals, mass cubes
  bool doRandPos=false;     // randomize galaxy positions in cells
  //bool HistoOnly=false; // only histogram of z
  //bool TrueZOnly=false; // only z
  //bool SimpleSim=false; // just ra,dec,z
  bool isZRadial=false;     // z dimension IS 'radial' direction
  int idsim = 1;
  float ngal_per_cell = 1;  // density of galaxies when no clustering
  
  
  //--- decoding command line arguments 
  char c;
  while((c = getopt(narg,arg,"hMzRGC:L:i:O:a:s:N:")) != -1) {
    switch (c) {
    case 'C' :
      cout << "CC " << optarg << endl;
      infile = optarg;
      break;
    case 'i' :
      sscanf(optarg,"%d",&idsim);
      break;
    case 'L' :
      inlfname   = optarg;
      break;
    case 'O' :
      outfile   = optarg;
      break;
    case 'G' :
      doVeryFaintCut = true;
      doGoldenCut = true;
      break;
    case 'M' :
      doVeryFaintCut = true;
      break;
    case 'a' :
      sscanf(optarg,"%lf",&maxRadius);
      doSkyAreaCut = true;
      break;
    case 'R' :
      doRandPos=true;
      break;            
    case 'z' :
      isZRadial=true;
      break;
    case 'N' :
      doDebug = true;
      debug_out = optarg;
      break;
    case 'h' :
    default :
      usage(); return -1;
    }
  }

                
  cout << "     Over-density grid will be read from "<< infile <<endl;

  cout << "     Output file will be "<< outfile <<":"<<endl;
  cout << "     Creating full galaxy catalog "<<endl;
  cout << " Luminosity functions read from " << inlfname <<endl; 
  cout << "     Simulation ID number is "<< idsim <<"00,000,000,000"<<endl; 
  if (doVeryFaintCut)
    cout << "     Removing galaxies with very faint absolute magnitudes"<<endl;
  if (doGoldenCut)
    cout << "     Removing galaxies with very faint absolute magnitudes (mi>25.3, golden cut) "<<endl;
  if (isZRadial)
    cout << "     z-dimension is of the input cube is 'radial dimension'"<<endl;
  if (doSkyAreaCut)
    cout << "     Keeping galaxies within theta<"<< maxRadius <<endl; 
  if (doRandPos)
    cout << "     Randomising galaxy positions within pixel"<<endl;
  //-- end command line arguments
        
  int rc = 1;  
  try {  // exception handling try bloc at top level
  
    
    // Track cpu resource usage
    ResourceUsage res;
    res.Update();
    cout << " Memory size (KB):" << res.getMemorySize() << endl;
    cout << " Max memory size (KB):" << res.getMaxMemorySize() << endl;
    cout << " Maximum allowed data segment size (KB):"<< res.getMaxDataSize() <<endl;
    cout << " Resource usage info : \n" << res << endl;
        
  
    // Read over-density grid
    cout << "     Reading input file= " << infile << endl;  
    FitsInOutFile fin(infile,FitsInOutFile::Fits_RO);
    TArray<r_8> drho;
    fin >> drho;
    cout << drho.Info();
    cout << "     Print original drho array size: "<< drho.SizeX() <<"x";
    cout << drho.SizeY() <<"x"<< drho.SizeZ() <<endl;
    cout << endl;
   
    string NXtrue_s, NXwritten_s;
    int NXtrue, NXwritten;
    NXtrue_s = fin.KeyValue("NZ");
    NXwritten_s = fin.KeyValue("NAXIS1");
    NXtrue = atoi(NXtrue_s.c_str());
    NXwritten = atoi(NXwritten_s.c_str());
    int xplanes = NXwritten - NXtrue; // SimLSS simulates cube with 1 or 2 extra planes: one dimension is too long
    // xplanes should be the difference between NX and drho.SizeX()

   
    // Initialize cosmological parameters 
    cout << "     Initialise cosmology: (same as SimLSS)"<<endl;

    //////////  modif Adeline : read cosmo in Fits_RO header
    string H0_s, OmegaM_s, OmegaL_s, OmegaB_s, OmegaR_s, wDE_s, wDA_s, Sigma8_s, Ns_s;
    double h, OmegaM, OmegaL, OmegaB, OmegaR, wDE, wDA, Sigma8, n_s;
    H0_s = fin.KeyValue("H0");
    OmegaM_s = fin.KeyValue("OMEGAM0");
    OmegaL_s = fin.KeyValue("OMEGADE0");
    OmegaB_s = fin.KeyValue("OMEGAB0");
    OmegaR_s = fin.KeyValue("OMEGAR0");
    wDE_s = fin.KeyValue("DE_W0");
    wDA_s = fin.KeyValue("DE_WA");
    Sigma8_s = fin.KeyValue("SIGMA8");
    Ns_s = fin.KeyValue("N_S");

    h = atof(H0_s.c_str()) / 100.;
    OmegaM = atof(OmegaM_s.c_str());
    OmegaL = atof(OmegaL_s.c_str());
    OmegaB = atof(OmegaB_s.c_str());
    OmegaR = atof(OmegaR_s.c_str());
    wDE = atof(wDE_s.c_str());
    wDA = atof(wDA_s.c_str());
    Sigma8 = atof(Sigma8_s.c_str());
    n_s = atof(Ns_s.c_str());
        
    SimpleUniverse su(h, OmegaM, OmegaL);
    su.SetOmegaBaryon(OmegaB);
    su.SetOmegaRadiation(OmegaR);
    su.SetSigma8(Sigma8);
    su.SetSpectralIndex(n_s);
    su.SetFlatUniverse_OmegaLambda(); // Cecile modif - to be sure that it is flat by adjusting OmegaLambda

    cout << "     OmegaK="<< su.OmegaCurv() <<", OmegaM="<< su.OmegaMatter();
    cout << ", OmegaL="<< su.OmegaLambda() <<", OmegaB="<< su.OmegaBaryon();
    cout << ", Omega_rad=" << su.OmegaRadiation() << ", Omega_cdm=" << su.OmegaCDM() <<", H0="<< su.H0() << endl;
    cout << "check flatness: OmegaTot=" << su.OmegaTotal() << endl;
    // Cecile modif
    if (wDE != -1 or wDA !=0)  
      su.SetDarkEnergy(su.OmegaLambda(),wDE,wDA);
        
    cout << " and w0=" << su.wDE() << ", wA=" << su.waDE() << ", sigma8=" << su.Sigma8() << endl;
    cout << "Spectral index=" << su.Ns() << endl;
    cout << endl;
        
        
    // Initialize Mass2Gal and remove N extra planes 
    cout << "     Initialise Mass2Gal: remove planes" << endl;
    RandomGenerator rg;
    Mass2Gal m2g(drho, su, rg, xplanes, isZRadial);
    double mean, sig;
    TArray<r_8> mass;
    m2g.MassArray(mass);
    MeanSigma(mass, mean, sig);
    cout << endl<<"     RAW DENS CUBE STATS: Mean=" << mean << " Sigma=";
    cout << sig <<endl<<endl;
    res.Update();
    cout << " Memory size (KB):" << res.getMemorySize() << endl;                                          
    cout << " Resource usage info : \n" << res << endl;
        
        
    // Read in cube and pixel properties from fits header
    cout << "     Read in cube properties from fits header" << endl;
    m2g.ReadHeader(fin);
    // xplanes should be the difference between NX and drho.SizeX()
    int NZ=m2g.ReturnNZ();
    int diff = drho.SizeX()-NZ;
    if( xplanes!=abs(diff) ) {
      cout << " rdlss/Error: drho.SizeX()="<<drho.SizeX()<<" - NZ="<<NZ<<" != xplanes="<<xplanes<<endl;
      cout << " ... removed wrong number of planes from SimLSS cube" << endl;
      throw ParmError("ERROR: removed wrong number of planes from SimLSS cube");
    }
    m2g.SetRandPos(doRandPos);


    // Deal with negative mass cells AND drho/rho -> rho/rho^bar 
    cout << "     Clean Negative Mass Cells" << endl;
    sa_size_t nbadc = m2g.CleanNegativeMassCells(); // adds 1 to drho and sets anything <0=0
    m2g.MassArray(mass);
    cout << "     NBadCells=" << nbadc 
         << " BadPercentage=" << (double)nbadc*100./(double)mass.Size() << "%"<<endl;
    MeanSigma(mass, mean, sig);
    cout << endl<<"     CLEANED DENS CUBE STATS: Mean=" << mean << " Sigma=";
    cout << sig << endl;
    // double check there are no bad cells 
    sa_size_t nbadc2 = m2g.CheckNegativeMassCells();
    cout <<"     double check there are no bad cells ...."<< nbadc2 <<endl;
    cout <<"     check minimum value in mass array is 0"<<endl;
    double min, max;
    mass.MinMax(min,max);
    cout <<"     min of mass = "<< min <<", max of mass = "<< max <<endl;
    cout << endl<<endl;
    res.Update();
    cout << " Memory size (KB):" << res.getMemorySize() << endl;
    cout << " Resource usage info : \n" << res << endl;
        
    cout << "     Convert rho/rho^bar To Mean NGal"<<endl;  

   /////////////////////////////////////////////////////////////////////////////////////

    string MstarUnits="M-5log10h70";
    string phistarUnits="(Mpc/h70)^-3";
    // Find conversion from mass density to galaxy density
    cout<<"     Mass to Galaxy number conversion"<<endl;
    double pixVol = m2g.ReturnPixVol();
    cout <<"    pixel volume="<< pixVol <<" Mpc^3"<<endl;

   ///////////////////////////////////// LF ////////////////////////////////////////////
    cout << "[1] Creating MultiType_Z_LF multLF(inlfname, MagMin, MagMax, useall) ..."<<endl;
    int nbmagpts=25;
    // bool useall=true;
    double magMin=-24., magMax=-13;
    //TEST
    bool useall=false;
    //double magMin=-24., magMax=-20.77;
    //TEST
    MultiType_Z_LF multLF(inlfname, magMin, magMax, nbmagpts, useall);
    cout << "... Creating and AutoInit of Random Generator ..."<<endl;
    FMTRandGen rg_lf;
    rg_lf.AutoInit(1);
    multLF.setRandomGenerator(&rg_lf);
    cout << multLF;
    
    cout << "[2] Checking interpolated Shchechter parameters..." << endl;
    cout << " z, multLF.getLF_Elliptical(z) / getLF_Spiral(z) / getLF_StarBurst(z) / multLF.getLF_All(z) -> Phistar Mstar alpha " << endl;
    for(double z=0.1; z<0.7; z+=0.05) {
      cout << " z="<<z<<" Ell: " << multLF.getLF_Elliptical(z) << " Sp: "<< multLF.getLF_Spiral(z)
	   << " SB: "<< multLF.getLF_StarBurst(z) << " All: "<< multLF.getLF_All(z) << endl;
      MySchechter lfEll = multLF.getLF_Elliptical(z);
    }
    
    cout << "[3] Checking interpolated number of galaxies ..." << endl;
    const char * ntnamesa[6]={"z","nEll","nSp","nSB","nAll","nGal"};
    NTuple nta(6,ntnamesa,128);
    double xnt[10];
    for(int i=0; i<100; i++) {
      double z=(double)i*0.05;
      xnt[0]=z;
      xnt[1]=multLF.getIntegral_Elliptical(z)*pixVol;
      xnt[2]=multLF.getIntegral_Spiral(z)*pixVol;
      xnt[3]=multLF.getIntegral_StarBurst(z)*pixVol;
      xnt[4]=multLF.getIntegral_All(z)*pixVol;
      xnt[5]=multLF.getGalaxyNumberDensity(z)*pixVol;
      if (i%5==0) cout << "z="<<z<<" ILF: Ell="<<xnt[1]<<" Sp="<<xnt[2]<<" SB="<<xnt[3]<<" All="<<xnt[4]
		       <<" NGal=?SumOrAll="<<xnt[5]<<endl;
      nta.Fill(xnt);
    }
    cout << nta;
    
    
    ////////////////////////////////////////////////////////////////////////////
    
    // Convert mass in each cell to a (mean) number of galaxies
    m2g.ConvertToMeanNGalLF(multLF, pixVol); // just multiplies mass_ by nGal(z)

    res.Update();
    cout << " Memory size (KB):" << res.getMemorySize() << endl;
    cout << " Resource usage info : \n" << res << endl;
    
    
    // Write out ngals and mass cubes for debugging
    if (doDebug) {
      
      cout <<"    **** Writing out cleaned mass distribution AND ngal distribution ****"<<endl;
      TArray<int_4> ngals;
      m2g.NGalArray(ngals);
      TArray<r_8>   mass2;
      m2g.MassArray(mass2);
      cout <<"    check minimum value in mass array is 0"<<endl;
      mass2.MinMax(min,max);
      cout <<"    min of mass = "<<min<<", max of mass = "<<max<<endl;
      string outngal = debug_out +"_ngals.fits";
      FitsInOutFile fos(outngal, FitsInOutFile ::Fits_Create);
      fos << ngals;
      cout <<"    Written ngals array"<<endl;
      
      string outmass = debug_out +"_mass.fits";
      FitsInOutFile fos1(outmass, FitsInOutFile ::Fits_Create);
      fos1 << mass2;
      cout <<"    Written mass array"<<endl;
      cout << endl;
    }
    
    //------------------------------------------------------------------------//
    // -- update to new classes: CumulDistM and DrawM
    
    // Create galaxy distributions
    cout <<"     Set up Mb-Type 2D distribution"<<endl;
    // set distribution parameters
    int magbin=10000;
    int PrtLevel = 2;
    string IntLFUnits="(Mpc/h70)^-3";
    cout <<"    Renormalise type-specific LFs ..."<<endl;

    if ( doVeryFaintCut && !doGoldenCut ) m2g.MaxAbsMag();

    // Simulate galaxies
    cout <<"     Simulate galaxies"<<endl;
    bool extinct=false;

    m2g.CreateGalCatalogLF(outfile, idsim, multLF, extinct, doVeryFaintCut, maxRadius, doGoldenCut);
    
  }  // End of try bloc 
  
  
  catch (PThrowable & exc) {  // catching SOPHYA exceptions
    cerr << " rdlss.cc: Catched Exception (PThrowable)" << (string)typeid(exc).name() 
         << "\n...exc.Msg= " << exc.Msg() << endl;
    rc = 96;
  }
  catch (std::exception & e) {  // catching standard C++ exceptions
    cerr << " rdlss.cc: Catched std::exception "  << " - what()= " << e.what() << endl;
    rc = 98;
  }
  catch (...) {  // catching other exceptions
    cerr << " rdlss.cc: some other exception (...) was caught ! " << endl;
    rc = 97;
  }
  cout << " ==== End of rdlss.cc program  Rc= " << rc << endl;
  return rc;    
}
